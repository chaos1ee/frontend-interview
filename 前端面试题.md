## 前端面试题

## HTML

### 延迟脚本

**共同点**

1. 都只适用于外部脚本；
2. 都有预先下载脚本但是会延迟执行脚本，当浏览器解析到 `</html> `标签时才会开始执行脚本；

**差异**

1. 提出的时间不一样的，defer是HTML4.01提出的标准，async是HTML5提出的；
2. defer会按照脚本先后顺序执行，async不是按照先后顺序执行。



## CSS

### BFC

Block Formatting Context，即块格式化上下文。它的主要作用是决定元素的定位。

视觉格式化模型定义了盒（Box）的生成，盒主要包括了块盒、行内盒、匿名盒（没有名字不能被选择器选中的盒）以及一些实验性的盒（未来可能添加到规范中）。盒的类型由`display`属性决定。

display： block，list-item或table

在定位的时候，浏览器就会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。定位时，有三种定位方案，分别是常规流，浮动以及绝对定位。

###1px直线

```css
height: 1px;
transform: scale(0.5);
```

### 盒模型的分类

```css
box-sizing: content-box 是W3C盒子模型
box-sizing: border-box 是IE盒子模型
```

### 上中下三栏布局



### 用css的方式画一个扇形

clip使用属性裁切出两个半圆，然后控制这两个半圆的旋转角度，以覆盖底下的圆形，使得图形部分显示。

```css
.pie{
  width: 200px;
  height: 200px;
  border-radius: 200px;
  background-color: deepskyblue;
}

.pie::before{
  content: "";
  width: 200px;
  height: 200px;
  position: absolute;
  background-color: white;
  border-radius: 200px;
  /*裁减半圆，再做旋转*/
  clip: rect(0px,100px,200px,0);
  transform: rotate(-90deg);
}

.pie::after{
  content: "";
  width: 200px;
  height: 200px;
  position: absolute;
  background-color: white;
  border-radius: 200px;
  /*裁减半圆，再做旋转*/
  clip: rect(0px,200px,200px,100px);
  transform: rotate(90deg);
}

```

###  sticky footer

```html
<div class="wrapper">
  <div class="content">
    <!-- 页面主体内容区域 -->
  </div>
  <div class="footer">
    <!-- 需要做到 Sticky Footer 效果的页脚 -->
  </div>
</div>
```

1. absolute定位 + min-height

```css
html, body {
  height: 100%;
}

.wrapper {
  position: relative;
  min-height: 100%;
  padding-bottom: 50px;
  box-sizing: border-box;
}

.footer {
  position: absolute;
  bottom: 0;
  height: 50px;
}
```

2. 

### `nth-child`和`nth-of-type`的区别

`nth-child` 选择父元素的第n个子元素，且该元素类型必须为所指定的类型。

`nth-of-type` 选择父元素中指定类型的子元素中的第n个。

html

```html
<div class="parent">
 <h1>test</h1>
 <p>test</p>
 <p>test</p>
</div>
```

css

```css
.parent p:nth-child(2)   /** 匹配第一个P元素 **/
.parent p:nth-of-type(2) /** 匹配第二个P元素 **/
```

### 利用html css 编写样式，div垂直body居中、div内的text垂直居中，div高度等于body宽度的一半

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
      }

      .container {
        position: absolute;
        width: 50vw;
        height: 50vh;
        border: 1px solid red;
        line-height: 50vh;
        top: 50%;
        left: 50%;
        text-align: center;
        transform: translate(-50%, -50%);
      }
    </style>
  </head>
  <body>
    <div class="container">text</div>
  </body>
</html>
```





## JavaScript

### 事件总线

```javascript
class Event {
  constructor() {
    
  }
  
  on() {
    
  }
  
  of() {
    
  }
  
  emit() {
    
  }
}
```

### bind 函数实现

```javascript
// 需要注意this指向
Function.prototype.bind = function bind(context, ...args1) {
  return (...args2) => this.apply(context, [...args1, ...args2]);
}
```

### 手写reduce

```js
Array.prototype.reduce = function() {
  const cb = arguments[0];
  const initialVal = arguments[1] ? arguments[1] : undefined;

  let ret;

  for (let i = 0; i < this.length; i++) {
    if (!initialVal) {
      initialVal = cb(this[i], this[i + 1], i, this);
      i++;
    } else {
      ret = cb(initialVal, this[i], i, this);
    }
  }

  return ret;
};
```



### 防抖

```javascript
function debounce(func, wait, immediate) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    if(timeout) clearTimeout(timeout);
    if(immediate) {
      timeout = setTimeout(function() {
      	timeout = null;
    	}, wait)
      if (callNow) func.apply(context, args)
    } else {
       timeout = setTimeout(function() {
      	func.apply(context, args);
    	}, wait)
    }
  }
}
```

### 变量未定义与未赋值的区别

变量未定义，会报错：

> Uncaught ReferenceError: xxx is not defined

变量已声明未赋值，该变量的初始值即为undefined，类型为undefined。

### 使用Promise模拟超时

将setTimeout和请求分别包装成Promise类型的数据，然后放置到Promise.race中。

```javascript
const request = new fetch(url, {
    method: 'post',
    headers: {
      "Content-type": "application/x-www-form-urlencoded; charset=UTF-8"
    },
  })

const timer  = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject('Timeout')
  }, 5000)
})

Promise.race([request, timer])
  .then(res => {
  	console.log(res);
	})
	.catch(err => {
  	console.err(err)
	})
```



###import 与 require的区别

1. 属于不同的标准。import属于ECMAScript2015规范，require属于commonjs规范。
2. 加载时间点不一样。require是动态加载，import是静态加载（也就是编译的时候就加载了）。
3. 输出值不一样。require/exports 的输出是值的拷贝，import/export的输出值是引用。



### 隐式转化 



## 设计模式

### 策略模式



### 观察订阅模式



### 单例模式



### 工厂模式

工厂模式是用来创建对象的一种最常用的设计模式。我们不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。工厂模式根据抽象程度的不同可以分为：`简单工厂`，`工厂方法`和`抽象工厂`。



## 算法

### 二叉树搜索算法



### 二叉树遍历



### 背包问题



### 最长子序列



### 二分法

```js
/**
 * @description 使用二分法实现indexOf方法
 * @author maybeeee
 */
Array.prototype.indexOf = Array.prototype.indexOf || function () {
  var left = 0;
  var right = this.length - 1;
  var middle;
  while (left <= right) {
    middle = Math.floor((left + right) / 2);
    if (this[middle] < arguments[0]) {
      left = middle + 1;
    } else if (this[middle] > arguments[0]) {
      right = middle - 1;
    } else {
      return middle;
    }
  }
  return -1
};
```

### 归并排序

归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。



合并二维有序数组成一维有序数组，归并排序的思路：

```javascript
function mergeSort(arr) {
  const len = arr.length;

  if (len < 2) {
    return arr[0];
  }

  const middle = Math.floor(len / 2);
  const left = arr.slice(0, middle);
  const right = arr.slice(middle);

  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  const ret = [];

  while (left.length && right.length) {
    if (left[0] <= right[0]) {
      ret.push(left.shift());
    } else {
      ret.push(right.shift());
    }
  }

  while (left.length) {
    ret.push(left.shift());
  }

  while (right.length) {
    ret.push(right.shift());
  }

  return ret;
}

const a = [1, 5, 8];
const b = [2, 3, 9, 11];
const c = [4, 6, 7, 10, 12];

console.log(mergeSort([a, b, c]));
```

### 斐波拉契

```js
function fibonacci(n) {
  if(n === 0 || n === 1) return n;
  return fibonacci(n-1) + fibonacci(n-2);
}
```

### 写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b,...,a+nb 的时间，然后写一个 myClear，停止上面的 mySetInterVal 

```javascript
// 1. 递归
// 2. 通过对象传递的是引用的特性，获取timeout id

function mySetInterVal(fn, a, b) {
  const timer = {};

  function circle(duration) {
    myClear(timer);
    
    timer.id = setTimeout(() => {
      fn();
      circle(duration + b);
    }, duration);
    
    return timer;
  }

  return circle(a);
}

function myClear(timer) {
  if (timer.id) {
    clearTimeout(timer.id);
  }
}

const foo = () => {
  console.log("a");
};

const timer = mySetInterVal(foo, 1000, 1000);

setTimeout(() => {
  myClear(timer);
}, 5000);
```



## 前端工具

### webpack

#### 构建流程

1. 初始化参数：从shell和配置文件读取、合并参数，得到最终的参数；
2. 开始编译：初始化Compiler对象，加载所有配置的插件，执行对象的run方法；
3. 确定入口：根据配置中的 entry 找出所有的入口文件；
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
5. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，最后将文件内容写入文件系统。



#### Loader和Plugin的不同？

**不同的作用**

- **Loader**直译为"加载器"。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到`loader`。 所以Loader的作用是让webpack拥有了加载和解析*非JavaScript文件*的能力。
- **Plugin**直译为"插件"。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

**不同的用法**

- **Loader**在`module.rules`中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个`Object`，里面描述了对于什么类型的文件（`test`），使用什么加载(`loader`)和使用的参数（`options`）
- **Plugin**在`plugins`中单独配置。 类型为数组，每一项是一个`plugin`的实例，参数都通过构造函数传入。



#### 熟悉的loader或者plugin

- babel-loader
- ts-loader
- style-loader 把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS
- HTMLWebpackPlugin



## 前端框架

### Vue

#### 什么是MVVM

#### 原理

数据劫持和观察订阅。





## HTTP



### HTTP 缓存

#### 缓存的分类

- 强缓存。服务器通知浏览器一个时间，下次请求的时候，若在有效期内直接使用缓存。若已经过期，则执行比较缓存策略。
- 协商缓存。客户端与服务器之间协商是否命中缓存。

HTTP请求都是从第二次请求开始的：

- 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；
- 第二次请求时，浏览器判断请求是否命中缓存，命中强缓存就直接返回200，否则就将请求参数添加到request header中，看是否命中协商缓存，命中则返回304，否则就返回新的资源。

#### 强缓存

##### header

- Cache-Control
- Expires

Cache-Control是一个相对时间，用以表示自上次请求正确的资源后多少秒的时间内缓存有效。Expires是一个绝对时间，表示在有效期内直接读取缓存，不发送HTTP请求。Cach-Control的优先级比Expiress高。

######Cache-Control

包含的属性：

- no-store：不缓存，每次都重新请求。
- no-cache： 每次都要向服务器验证缓存是否过期。
- private： 只有客户端可以缓存，代理服务器不能缓存。
- public：客户端与代理服务器都可以缓存。
- max-age：至上一次成功请求资源多少秒后资源过期。
- must-revalidate：如果超过了 `max-age` 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。

###### Expires

告诉浏览器在过期前可以直接从浏览器拉取数据。





## Nodejs

### Koa

#### 什么是koa 

 koa是一个基于nodejs的web框架。

#### 中间件机制

koa的中间件机制是一个洋葱式的模型，多个中间件通过use放进一个队列然后从外层开始执行，遇到next后进入队列中的下一个中间件，所有中间件执行完后开始执行队列中之前中间件中未执行的代码部分，这就是剥洋葱模型，koa的中间件机制。



## HTTP

### tcp为什么是可靠的

https://blog.csdn.net/Awille/article/details/79748193

### http握手原理



## 我的项目

oidc是一个认证协议，它基于OAuth2.0协议族

从抽象的角度来看，OIDC的流程由以下5个步骤构成：

1. RP发送一个认证请求给OP；
2. OP对EU进行身份认证，然后提供授权；
3. OP把ID Token和Access Token（需要的话）返回给RP；
4. RP使用Access Token发送一个请求UserInfo EndPoint；
5. UserInfo EndPoint返回EU的Claims。

![img](https://images2015.cnblogs.com/blog/168328/201705/168328-20170530092134102-504300351.jpg)



### 1面

讲一下浏览器和服务器建立连接的流程。

大致流程

1. URL 解析
2. DNS 查询
3. TCP 连接
4. 处理请求
5. 接受响应
6. 渲染页面

```tex
1.域名解析。也就是DNS查询，这一步主要是去查找域名对应的IP地址。DNS查询会先查找本地缓存，如果没有缓存，就访问DNS服务器查找ip。
2.TCP连接。在浏览器发送HTTP请求之前，需要在浏览器和服务器之间建立一条TCP/IP连接。每一条TCP连接唯一地被通信两端的两个端点(即两个套接字)所确定，TCP连接的端点叫做套接字(socket)。TCP连接主要分为建立连接(三次握手)，数据传输，断开连接(四次挥手)
```

讲一下http协议。

```

```

我如果要上传一个文件，该怎么发起请求。

```
请求方式：

1.表单提交

给form元素设置这三个属性

action="http://localhost:8899/react/aa" method="post" enctype="multipart/form-data"

2.formData
 js file api
 formdata可以上传二制文件
 读取file对象;
 构造formData对象;
 通过ajax上传  设置头 'content-type':'multipart/form-data'，fetch不需要设置这个请求头.

```

为什么multipart/form-data 的 header里有boundary ，为什么有这个？

```
https://stackoverflow.com/questions/3508338/what-is-the-boundary-in-multipart-form-data

只是为了分割数据
```

CSS flex属性有哪些，盒子模型，BFC。

```
flex-flow，flex-direction，flex-wrap，justify-content，align-items，flex-shrink，flex-grow等等

按照盒模型的理念，元素被划分为一个个标准的方框，盒模型决定如何去计算盒子的尺寸。分为IE盒模型和标准盒模型。

1.IE盒模型 box-sizing：border-box 内容的宽度 = border + padding + width 内容的高度 = border + padding + height
2.标准盒模型 box-sizing：content-box 内容的宽度 = width 内容的高度 = heigh
```

代码题：

传入一个 排序好了的数组，（[1,2,3,4,5,6,7]） ,传入一个n, 返回数组里两个数相加等于n的结果，返回这两个数的索引。

```javascript
var twoSum = function(numbers, target) {
 let l = 0;
 let r = numbers.length - 1;
  
  while(l < r) {
    if(numbers[l] + numbers[r] < target) {
      l++;
    } else if(numbers[l] + numbers[r] > target) {
      r--;
    } else {
      return [l , r]
    }
  }
};
```

2面

Webpack优化，less文件的解析怎么做到的？

项目里你说做了Webpack的优化，做了哪些优化？



笔试题：

版本号排序，乱序的版本号排序成['1.1','1.7','1.10','2.3.3','2.4.1','3.30.33.3']

```javascript
function versionsSort(versions) {
  const ret = versions.map(version => version.split("."));

  for (let i = 0; i < ret.length - 1; i++) {
    for (let j = i; j < ret.length; j++) {
      if (compare(ret[i], ret[j])) {
        [ret[i], ret[j]] = [ret[j], ret[i]];
      }
    }
  }

  return ret.map(item => item.join("."));
}

function compare(arr1, arr2) {
  const minLen = Math.min(arr1.length, arr2.length);

  let index = 0;

  while (index <= minLen) {
    if(arr1[index] !== arr2[index]) {
      return +arr1[index] > +arr2[index];
    } else {
      if(index < minLen) {
        index++;
      } else {
        return arr1.length < arr2.length;
      }
    }
  }
}

const arr = ["1.7", "1.2.2", "2.3.3", "1.10", "2.4.1", "3.30.33.3", "1.1"];

// ["1.1", "1.2.2", "1.7", "1.10", "2.3.3", "2.4.1", "3.30.33.3"]
console.log(versionsSort(arr));
```

3面

webpack的treeshaking，还有一个叫作用域提升的优化，这个是做什么的？

浏览器打开一个页面，会起多少个进程和线程？

ServiceWorker是进程还是线程？

代码题：

写一个方法，这个方法接收两个参数，第一个参数是一个url的数组，第二个参数是n， 表示同时发起n个请求去获取这个数组里的结果。

```js

```



四面 业务leader面

技术问题问了两个，一个React diff





成都头条第二次面

1面

PWA主要解决了什么问题？它优点有哪些？

为什么说serviceWorker是一个nginx？

缓存技术可以用哪些？

如果要推广你的脚手架，你会怎么去说服其他团队的人？

PWA现在可以直接运行在iOS或者Android上吗？

UML里，继承怎么用箭头表示？（我这个答错，我说的空心三角形指向子类，正确的答案应该是指向父类）

HTTPS如果要请求一个http的资源，浏览器里面的的报错是什么？(记不住，没答上来)

```
混合内容在以下情况下出现：初始 HTML 内容通过安全的 HTTPS 连接加载，但其他资源（例如，图像、视频、样式表、脚本）则通过不安全的 HTTP 连接加载。之所以称为混合内容，是因为同时加载了 HTTP 和 HTTPS 内容以显示同一个页面，且通过 HTTPS 加载的初始请求是安全的。现代浏览器会针对此类型的内容显示警告，以向用户表明此页面包含不安全的资源。
```

笔试题：3-sum.



北京头条一面



React生命周期，fiber调度。

Vue的双向绑定的实现，有哪些方式。

有一个页面A，使用iframe的方式嵌入了和A相同url的页面A', 问有哪些方式可以让两个页面通信？

```tex
同源页面间的通信
1. localstorage
当 LocalStorage 变化时，会触发 storage 事件。利用这个特性，我们可以在发送消息时，把消息写入到某个 LocalStorage 中；然后在各个页面内，通过监听 storage 事件即可收到通知。
需要注意的是：我们在setItem的value上添加了一个当前毫秒时间戳的ts字段。因为 storage 事件只有在值改变时才会触发。
如果两次调用setItem时存储的value一致，那么第二次不会触发 storage 事件。
2. BroadCast Channel
BroadCast Channel 可以创建一个用于广播的通信频道。当所有页面都监听同一频道时，其中一个页面通过它广播的消息就会被其他所有页面收到。

创建一个频道名称为broadcast-channel的频道：
const broadcastChannel = new BroadcastChannel('broadcast-channel');

各个页面通过onmessage监听被广播的消息：
broadcastChannel.onmessage = (e) => {
  this.message = `Received message: ${e.data.msg}`;
};

发送消息时只需要调用实例上的postMessage方法即可：
broadcastChannel.postMessage({
  msg,
});

Safari 不支持 BroadcastChannel
BroadcastChannel 不会持久化，比 localStorage 方案更干净
3. Shared Worker
4. Service Worker
Service Worker 是 PWA （渐进式Web应用）中的核心技术之一，不过在这里用它来做页面间通信。

Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面注册的同一个 Service Worker 可以共享，将 Service Worker 作为消息中转站即可实现广播效果。
5. 获取对应窗口的引用，调用 window.postMessage()
```



笔试题：

和成都面试的那个题差不多，3-sum



二面

Redux,Connect组件怎么做到的？

React-Router的实现

讲一下为啥React Hook里面要去不能用if else的条件去隔开react hook

（二面我说了很多 Webpack优化和 提取脚手架和CLI工具的内容，面试官）



笔试题：

[[a,b],[C,D],[1,2]] 返回 [aC1,aC2,aD1.aD2,bC1,bC2 ....] 

思路是暴力循环，然后想怎么优化，这里面试官提示了怎么优化，leetcode上好像有这个题。



三面

笔试题：一个二叉树，给一个数为n，返回这个二叉树里是否存在一个路径，使得路径上节点上的值相加等于n.

前端实现动画有哪些方式？（我答了，可能不是很完整，利用已经存在的state,比如hover checked；改class属性；改style属性；keyframes）

动画的优化（说了从影响layout 还是paint, 分layer去优化，将拖累整个layer的dom元素移动到新的layer，比如用tranform:tanslate3D, position:absolute这样）

layout的计算在哪里？（这个没懂面试官要问什么,我说在UI Render这个东西里面，具体看http://taligarsiel.com/Projects/howbrowserswork1.htm）



Nodejs并发（说了cluster利用多核）

为了保证线上node服务的稳定性，你会做哪些操作去保证呢？（异常监控和处理，守护进程，统计请求的执行时间，统计内存判断是否有内存溢出）

如果PM要求获取用户访问页面的热力图，你会怎么做？开放性问题。（明确PM的目的，获取数据，保存数据，展示数据。）

会收集哪些数据？（鼠标在页面的位置，时长）

如果页面是ABTest的，怎么办？比如原来按钮在左边，现在换到了右边。

如果页面内容的东西因为业务需求改变了怎么办？比如banner换了，换成不同的业务的了。

如果页面是responsive的怎么办？比如不同分辨率或者用户拖动页面了怎么办？







一轮

1.dom react原理 https://www.cnblogs.com/yumingxing/p/9438457.html

2.css布局

3.js原型链继承

```
每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.
```

4.fetch取消 https://www.jb51.net/article/161492.htm

```javascript
//  Fetch超时的实现 setTimeout + Promise.race
let timeoutPromise = (timeout) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("我是 timeoutPromise，已经完成了");
        }, timeout);
    });
}
let requestPromise = (url) => {
    return fetch(url);
};
Promise.race([timeoutPromise(1000), requestPromise("https://www.baidu.com")])
    .then(resp => {
        console.log(resp);
    })
    .catch(error => {
        console.log(error);
    });

//  Fetch取消的实现AbortController + 超时
let controller = new AbortController();
let signal = controller.signal;

let timeoutPromise = (timeout) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(new Response("timeout", { status: 504, statusText: "timeout " }));
            controller.abort();
        }, timeout);
    });
}
let requestPromise = (url) => {
    return fetch(url, {
        signal: signal
    });
};
Promise.race([timeoutPromise(1000), requestPromise("https://www.baidu.com")])
    .then(resp => {
        console.log(resp);
    })
    .catch(error => {
        console.log(error);
    });

```

5.eventloop https://juejin.im/post/5b8f76675188255c7c653811

```javascript
/**
* NodeJS的Event Loop过程：
* 执行全局Script的同步代码
* 执行microtask微任务，先执行所有Next Tick Queue中的所有任务，再执行Other Microtask Queue中的所有任务
* 开始执行macrotask宏任务，共6个阶段，从第1个阶段开始执行相应每一个阶段macrotask中的所有任务，注意，这里是* 所有每个阶段宏任务队
* 列的所有任务，在浏览器的Event Loop中是只取宏队列的第一个任务出来执行，每一个阶段的macrotask任务执行完毕后，开始执行微任务，也就
* 是步骤2 Timers Queue -> 步骤2 -> I/O Queue -> 步骤2 -> Check Queue -> 步骤2 -> Close Callback Queue -> 步骤2 -> 
* Timers Queue ......
*/
```

6.instanceof instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。

7.promise封装setstate

8.redux基本组成和设计单向数据流

9.https协议的过程 https://www.jianshu.com/p/f6b34381beac

10.https获取加密密钥的过程 参考1-9

11.http的方法有哪几种,每种方法的有用途 https://www.runoob.com/http/http-methods.html

12.类式继承的方案 参考1-49

13.prototype继承的实现 参考1-49

14.数字千分位处理，正则和非正则都要实现 https://www.cnblogs.com/lvmylife/p/8287247.html­

15.借用构造继承，几种组合继承方式 参考1-49

16.看编程代码说出运行结果：

Process.nextTick，setImmediate 和promise.then 的优先级 https://www.oschina.net/translate/understanding-process-next-tick?print

Process.nextTick，pronise, setImmediate的优先级

17.实现一个bind函数

18.千位加逗号 参考1-14

19.三个继承方式的优缺点 优化列出代码 参考1-49

20.Nodejs的事件循环 参考1-5

21.bfc https://blog.csdn.net/return_js/article/details/81266131

22.css实现正方形div水平垂直居中

23.koa1的原理,继承

24.最后是一个写代码 处理有依赖的异步任务 加重试

\25. diff的原理 https://www.jianshu.com/p/8c1505ebcf0e

\26. es6箭头函数 https://www.cnblogs.com/mengff/p/9656486.html

\27. import和requre的区别 https://www.cnblogs.com/sunshq/p/7922182.html

\28. symbol https://www.jianshu.com/p/f40a77bbd74e

\29. 函数实现正面模板

\30. 正方形实现，三角形实现

\31. CSS考了 伪类 https://www.jianshu.com/p/4c9902b6e8de

\32. 实现布局header,content,footer，上中下布局；当content 超出窗口可视区，不显示footer；当content 没超出可视区时，固定footer 在最下面

\33. 算法:



42.react 新版本的特性

\43. 多空格字符串格式化为数组

46、数字千分位处理 https://www.jb51.net/article/116348.htm

47、固定日期与当前时间格式化处理

48、上中下三栏布局

49、实现一个子类实例可以继承父类的所有方法 https://www.jianshu.com/p/3eb7a1843009

\50.  Jsonp跨域，js原型继承 & 原型链，promise
